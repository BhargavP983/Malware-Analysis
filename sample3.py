import os
import magic
import hashlib
from pefile import PE
import string
import json
import lief


def static_analysis(folder_path):
    results = []

    # Iterate through all files in the folder
    for filename in os.listdir(folder_path):
        filepath = os.path.join(folder_path, filename)
        if os.path.isfile(filepath):
            result = {}
            with open(filepath, 'rb') as f:
                file_data = f.read()
                filesize = len(file_data)
                filehash = hashlib.sha256(file_data).hexdigest()

                # Determining file type
                ftype = magic.from_file(filepath, mime=True)
                result["file_type"] = ftype

                # calculate File size
                result["filesize"] = filesize

                # File Hash
                result["sha256"] = filehash

                if ftype.startswith("application/x-dosexec") or ftype.startswith("application/x-ms-dos-executable"):
                    try:
                        pe = PE(data=file_data)
                        result["machine"] = hex(pe.FILE_HEADER.Machine)
                        result["magic"] = hex(pe.OPTIONAL_HEADER.Magic)

                        # Additional features extracted for PE files
                        result["number_of_sections"] = pe.FILE_HEADER.NumberOfSections
                        result["entry_point"] = pe.OPTIONAL_HEADER.AddressOfEntryPoint

                        # Extracting imports
                        imports = []
                        for entry in pe.DIRECTORY_ENTRY_IMPORT:
                            for imp in entry.imports:
                                if imp.name:
                                    imports.append(imp.name.decode())
                        result["imports"] = imports

                        # Extracting exports
                        exports = []
                        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                                exports.append(exp.name.decode())
                        result["exports"] = exports

                        sections = []
                        for section in pe.sections:
                            sections.append({
                                "name": section.Name.decode().strip('\x00'),
                                "virtual_address": hex(section.VirtualAddress),
                                "virtual_size": hex(section.Misc_VirtualSize),
                                "raw_size": hex(section.SizeOfRawData),
                                "entropy": section.get_entropy()
                            })
                        result["sections"] = sections

                    except Exception as e:
                        print(f"Error analyzing {filename}: {e}")
                elif ftype.startswith("application/x-executable"):
                    try:
                        # Open the binary with LIEF
                        binary = lief.parse(file_data)

                        # Extract header information
                        result["architecture"] = str(binary.header.architecture)
                        result["entrypoint"] = hex(binary.entrypoint)
                        result["format"] = binary.header.format

                        # Extract sections information
                        sections = []
                        for section in binary.sections:
                            sections.append({
                                "name": section.name,
                                "virtual_address": hex(section.virtual_address),
                                "size": hex(section.size),
                                "entropy": section.entropy
                            })
                        result["sections"] = sections

                        # Extract imported functions
                        imported_functions = []
                        if binary.imports:
                            for lib in binary.imports:
                                for imp in lib.entries:
                                    imported_functions.append(imp.name)
                        result["imported_functions"] = imported_functions

                        # Additional features for other types of executables
                        # Extracting strings from executable
                        strings = []
                        for c in string.printable:
                            substr = bytes(c, 'ascii')
                            if substr in file_data:
                                strings.append(c)
                        result["strings"] = strings

                    except Exception as e:
                        print(f"Error analyzing {filename}: {e}")
            results.append(result)
    return results

# Yara Rules Comparison
def compare_with_yara(filepath, yara_rules):
    matches = []
    try:
        # Load Yara rules
        if isinstance(yara_rules, str):  # If it's a file path
            with open(yara_rules, 'r') as f:
                yara_rules = f.read()
        compiled_rules = yara.compile(source=yara_rules)

        # Perform static analysis
        analysis_results = static_analysis(filepath)

        # Convert each feature dictionary to a string
        features_str = [json.dumps(feature) for feature in analysis_results]

        # Join the features into a single string
        features_joined = '\n'.join(features_str)

        # Scan the data with the compiled rules
        matches_tmp = compiled_rules.match(data=features_joined)

        if matches_tmp:
            matches.extend([match["rule"] for match in matches_tmp])
    except Exception as e:
        print(f"Error during Yara matching: {e}")
    return matches


# Input folder path
folder_path = input("Enter the folder path containing executable files: ")

# Input folder path for YARA rules
rules_file = input("Enter the folder path containing YARA rules: ")

# Compare with Yara rules
matched_rules = compare_with_yara(folder_path, rules_file)
if matched_rules:
    print(f"Matched Yara Rules: {', '.join(matched_rules)}")
    print("**WARNING: Potential Malware Detected**")
else:
    print("No Yara rule matches found.")


folder_path = "Executables"

# Perform static analysis
results = static_analysis(folder_path)
for result in results:
    for value in result.items():
        print(f"{value}")